package main

import (
	"bufio"
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"strings"

	_ "github.com/go-sql-driver/mysql"
	openai "github.com/sashabaranov/go-openai"
)

var config Config

// Config 存储数据库和AI配置
type Config struct {
	MySQLHost     string
	MySQLPort     string
	MySQLUser     string
	MySQLPassword string
	MySQLDatabase string
	OpenAIAPIKey  string
	OpenAIBaseURL string
	OpenAIModel   string
}

// TableInfo 存储表结构信息
type TableInfo struct {
	TableName   string
	Columns     []ColumnInfo
	Indexes     []IndexInfo
	CreateTable string
}

// ColumnInfo 存储列信息
type ColumnInfo struct {
	Field   string
	Type    string
	Null    string
	Key     string
	Default sql.NullString
	Extra   string
}

// IndexInfo 存储索引信息
type IndexInfo struct {
	IndexName  string
	ColumnName string
	NonUnique  int
}

// ExplainResult 存储EXPLAIN结果
type ExplainResult struct {
	ID           int
	SelectType   string
	Table        string
	Partitions   string
	Type         string
	PossibleKeys string
	Key          string
	KeyLen       string
	Ref          string
	Rows         int
	Filtered     float64
	Extra        string
}

// AnalysisRequest 发送给AI的请求结构
type AnalysisRequest struct {
	SQLQuery    string
	TableInfos  []TableInfo
	ExplainPlan []ExplainResult
}

func main() {

	// 解析命令行参数
	flag.StringVar(&config.MySQLHost, "host", "localhost", "MySQL host")
	flag.StringVar(&config.MySQLPort, "port", "3306", "MySQL port")
	flag.StringVar(&config.MySQLUser, "user", "root", "MySQL username")
	flag.StringVar(&config.MySQLPassword, "password", "", "MySQL password")
	flag.StringVar(&config.MySQLDatabase, "database", "", "MySQL database name")
	flag.StringVar(&config.OpenAIAPIKey, "openai-key", "", "OpenAI API key")
	flag.Parse()

	// 从环境变量读取OpenAI配置
	config.OpenAIBaseURL = "https://openrouter.ai/api/v1/"
	config.OpenAIModel = "deepseek/deepseek-chat-v3-0324:free"

	// 连接MySQL
	db, err := connectMySQL(config)
	if err != nil {
		log.Fatalf("Failed to connect to MySQL: %v", err)
	}
	defer db.Close()

	// 获取用户输入的SQL
	fmt.Println("Please enter the SQL query to analyze:")
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Scan()
	sqlQuery := strings.Trim(scanner.Text(), `"`)
	if err := scanner.Err(); err != nil {
		log.Fatalf("Failed to read SQL query: %v", err)
	}

	// 获取SQL涉及的表
	tables, err := extractTablesFromSQL(sqlQuery)
	if err != nil {
		log.Fatalf("Failed to extract tables from SQL: %v", err)
	}

	// 收集表结构信息
	var tableInfos []TableInfo
	for _, table := range tables {
		info, err := getTableInfo(db, table)
		if err != nil {
			log.Printf("Failed to get info for table %s: %v", table, err)
			continue
		}
		tableInfos = append(tableInfos, info)
	}

	// 执行EXPLAIN
	explainResults, err := executeExplain(db, sqlQuery)
	if err != nil {
		log.Fatalf("Failed to execute EXPLAIN: %v", err)
	}

	// 准备AI请求
	request := AnalysisRequest{
		SQLQuery:    sqlQuery,
		TableInfos:  tableInfos,
		ExplainPlan: explainResults,
	}

	// 发送给AI分析
	analysis, err := sendToAI(config.OpenAIAPIKey, request)
	if err != nil {
		log.Fatalf("Failed to get AI analysis: %v", err)
	}

	// 输出分析结果
	fmt.Println("\nAI Analysis:")
	fmt.Println(analysis)
}

func getEnv(key, defaultValue string) string {
	value := os.Getenv(key)
	if value == "" {
		return defaultValue
	}
	return value
}

func connectMySQL(config Config) (*sql.DB, error) {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true",
		config.MySQLUser,
		config.MySQLPassword,
		config.MySQLHost,
		config.MySQLPort,
		config.MySQLDatabase)

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return nil, err
	}

	if err = db.Ping(); err != nil {
		return nil, err
	}

	return db, nil
}

func extractTablesFromSQL(sqlQuery string) ([]string, error) {
	// 简单的表名提取逻辑，实际应用中可能需要更复杂的解析
	// 这里只是一个简单示例，实际应该使用SQL解析器
	var tables []string
	words := strings.Fields(sqlQuery)
	for i, word := range words {
		if strings.EqualFold(word, "FROM") || strings.EqualFold(word, "JOIN") {
			if i+1 < len(words) {
				table := strings.Trim(words[i+1], "`;")
				tables = append(tables, table)
			}
		}
	}
	return tables, nil
}

func getTableInfo(db *sql.DB, tableName string) (TableInfo, error) {
	var info TableInfo
	info.TableName = tableName

	// 获取列信息
	rows, err := db.Query(fmt.Sprintf("DESCRIBE `%s`", tableName))
	if err != nil {
		return info, err
	}
	defer rows.Close()

	for rows.Next() {
		var col ColumnInfo
		var def sql.NullString
		err := rows.Scan(&col.Field, &col.Type, &col.Null, &col.Key, &def, &col.Extra)
		if err != nil {
			return info, err
		}
		col.Default = def
		info.Columns = append(info.Columns, col)
	}

	// 获取索引信息
	indexRows, err := db.Query(fmt.Sprintf("SHOW INDEX FROM `%s`", tableName))
	if err != nil {
		return info, err
	}
	defer indexRows.Close()

	for indexRows.Next() {
		var idx IndexInfo
		var dummy1, dummy2, dummy3, dummy4, dummy5, dummy6, dummy7, dummy8, dummy9, dummy10, dummy11, dummy12, dummy13 interface{}
		err := indexRows.Scan(
			&dummy1, // Table
			&idx.NonUnique,
			&idx.IndexName,
			&dummy2, // Seq_in_index
			&idx.ColumnName,
			&dummy3,  // Collation
			&dummy4,  // Cardinality
			&dummy5,  // Sub_part
			&dummy6,  // Packed
			&dummy7,  // Null
			&dummy8,  // Index_type
			&dummy9,  // Comment
			&dummy10, // Index_comment
			&dummy11, // Visible
			&dummy12, // Expression
			&dummy13, // Clustered
		)
		if err != nil {
			return info, err
		}
		info.Indexes = append(info.Indexes, idx)
	}

	// 获取CREATE TABLE语句
	var createTable string
	err = db.QueryRow(fmt.Sprintf("SHOW CREATE TABLE `%s`", tableName)).Scan(&tableName, &createTable)
	if err != nil {
		return info, err
	}
	info.CreateTable = createTable

	return info, nil
}

func executeExplain(db *sql.DB, sqlQuery string) ([]ExplainResult, error) {
	var results []ExplainResult

	// Remove EXPLAIN if already present
	query := strings.TrimSpace(sqlQuery)
	if strings.HasPrefix(strings.ToUpper(query), "EXPLAIN ") {
		query = query[8:]
	}

	rows, err := db.Query(fmt.Sprintf("EXPLAIN %s", query))
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var res ExplainResult
		var partitions, possibleKeys, key, keyLen, ref, extra sql.NullString
		var filtered sql.NullFloat64

		err := rows.Scan(
			&res.ID,
			&res.SelectType,
			&res.Table,
			&partitions,
			&res.Type,
			&possibleKeys,
			&key,
			&keyLen,
			&ref,
			&res.Rows,
			&filtered,
			&extra,
		)
		if err != nil {
			return nil, err
		}

		res.Partitions = partitions.String
		res.PossibleKeys = possibleKeys.String
		res.Key = key.String
		res.KeyLen = keyLen.String
		res.Ref = ref.String
		res.Filtered = filtered.Float64
		res.Extra = extra.String

		results = append(results, res)
	}

	return results, nil
}

func sendToAI(apiKey string, request AnalysisRequest) (string, error) {
	if apiKey == "" {
		return "OpenAI API key not provided. Skipping AI analysis.", nil
	}

	clientConfig := openai.DefaultConfig(apiKey)
	if config.OpenAIBaseURL != "" {
		baseURL := strings.Trim(config.OpenAIBaseURL, `"`)
		baseURL = strings.TrimRight(baseURL, "/")
		clientConfig.BaseURL = baseURL
	}

	client := openai.NewClientWithConfig(clientConfig)

	// 创建流式请求
	stream, err := client.CreateChatCompletionStream(
		context.Background(),
		openai.ChatCompletionRequest{
			Model: config.OpenAIModel,
			Messages: []openai.ChatCompletionMessage{
				{
					Role:    openai.ChatMessageRoleUser,
					Content: preparePrompt(request),
				},
			},
			Stream: true,
		},
	)
	if err != nil {
		return "", err
	}
	defer stream.Close()

	fmt.Println("\nAI Analysis:")
	var fullResponse strings.Builder

	for {
		response, err := stream.Recv()
		if errors.Is(err, io.EOF) {
			fmt.Println("\n")
			return fullResponse.String(), nil
		}

		if err != nil {
			return "", fmt.Errorf("stream error: %v", err)
		}

		content := response.Choices[0].Delta.Content
		fmt.Print(content)
		fullResponse.WriteString(content)
	}
}

func preparePrompt(request AnalysisRequest) string {
	// 将请求数据转换为JSON以便于AI理解
	jsonData, _ := json.MarshalIndent(request, "", "  ")

	return fmt.Sprintf(`我有一个MySQL查询分析请求。请分析以下信息并提供：

1. 对EXPLAIN计划结果的解释，特别是每种SelectType和Type为何具有当前值
2. 基于表结构和索引的查询优化建议
3. 当前查询执行计划中可能存在的问题

以下是JSON格式的分析请求数据：

%s

请提供详细的回复，包含清晰的解释和可操作的优化建议。`, jsonData)
}
